## Part 1a 

1. values added: 20
2. final result: 20
3. values added: 20
4. error, result is not defined outside the if condition because let declarance is only within block scope
5. The code returns an error in line 7 because it can't reassign result, but if it is able to ignore that error then line 9 would return "values added: 0"
6. error, result is not defined outside the if condition because const declarance is only within block scope

## Part 1b
1. line 12 will print i after it goes through the for loop, which would end up to be prices.length, or "3". This is because var has no block scope, so if it's defined within a function then it has function level scope, so the i in the for loop is preserved and it was last incremented to 3
2. line 13 will print discountedPrice after it's last iteration, which would be "150". This is because var has no block scope, so if it's defined within a function then it has function level scope, so the discountedPrice in the for loop is preserved and it was last changed to 300*(1-0.5) which is 150
3. line 14 will print finalPrice after it's last iteration, which would also be "150". This is because var has no block scope, so if it's defined within a function then it has function level scope, so the finalPrice in the for loop is preserved and it was last changed to what discountedPrice was, but multiplied by 100 and then divided by 100 and then rounded, which would still give us "150".
4. The function would return discounted with all the final prices, so it would be an array containing [50,100,150]. This is because we created the discounted array, then in the for loop we applied the discount parameter to every individual element in the prices parameter array, and after each discountedPrice we rounded it to finalPrice and pushed it to the discounted array, so all the discounted prices would be held in the discounted array. All the vairables were var, so there wouldn't be any issues with block scopes.
5. line 12 will give an error because i is declared using let in the for loop, so it only has a block scope within the for loop. Since the console.log is outside the for loop, then it would give us an error that there is no such variable.
6.  line 13 will give an error because discountedPrice is declared using let in the for loop, so it only has a block scope within the for loop. Since the console.log is outside the for loop, then it would give us an error that there is no such variable
7.  line 14 would print to console "150". This is because although finalPrice is declared using let, it was declared outside the for loop and in the function so it's scope is within the function. Thus, anything done in the for loop to finalPrice would still apply outside the loop, and it holds the value from the last iteration of the for loop which was rounding discountedPrice of 150, which would still be 150.
8.  This function would return the discounted array since it was declared using the let keyword outside of the for loop and in the function, so it would have the scope of the function. Everything in the for loop does the calculations then pushed to the discounted array, so in the end it would return [50,100,150].
9.  Line 11 would throw an error that i is not defined. The const variables do not cause any troubles because they are declared in their respective scopes and not used in any other scope, and they aren't assigned to any other value. The const discountedPrice in the for loop does not cause an error because it resets every iteration so it doesn't save the const variable from the previous iteration. The only error is that the variable i is declared using let in the for loop, so once we try to print it to console in line 11 it throws an error because i was never declared in this scope.
10. Line 12 will print "3", and this is because the program is the same as the previous once with just the change of printing length instead of i, so the const variables don't cause any trouble. We are printing a const variable length and it would always be 3 because that is the length of the prices parameter.
11. The function will return the discounted array. As before, the const variables don't cause any trouble, and pushing to a const array is allowed since we are not reassigning it to discounted. Thus, we return "[50,100,150]"
12. Object Notation
    1.  A. student.name     
    2.  B. student["Grad Year"]     
    3.  C. student.greeting()   
    4.  D. student['Favorite Teacher'].name     
    5.  E. student.courseload[0]
13. Arithmetic
    1.  A. '32' is the output because '3' is a string and so the + operator would be treated as string concatenation, so the automatic type conversion converts 2 to '2', and it is concatenated to '32'
    2.  B. 1 is the output because we can't unadd 2 from the string of 3 with the operator - so the auto converter decides the '3' gets converted to a number 3 and then performs subtraction 3-2 as most fit
    3.  C. 3 is the ouput because 3 stays as a number and null gets converted into its numeric value which is 0 so that the operation + could be performed, which we end up with 3
    4.  D. '3null' is the output because since '3' is a string and we are trying to perform +, then it is going to try and treat it as string concatenation so then null gets converted to a string 'null' and we concatenate the two to '3null'
    5.  E. 4 is the output because we have a true boolean and a number 3, and since there is a + operator with no strings then it would be treated as addition of numbers, so true gets converted to its numberic value of 1 and we end up with 4
    6.  F. 0 is the output because there are no strings so the operator + is treated as numeric addition. The numeric conversion of false is 0 and null is 0 as well, so 0 + 0 = 0.
    7.  G. '3undefined' is the output because we have a string of '3' and there is a + operator so we treat it as string concatenation, so then we convert undefined as a string to be 'undefined', concatenating the two to be '3undefined'
    8.  H. NaN is the output because although there is a string '3', the subtraction operator means we have to perform a mathematical operation so we convert '3' to 3 and undefined to its numeric value of NaN or not a number, so then 3-NaN is NaN
14. Comparison
    1.  A. true is the output because in comparison of different types, Javascript converts the values to numbers, so '2' is converted to 2 and 2 is greater than 1, outputting true
    2.  B. false is the output because both are strings so we are comparing lexicographical order, and so comparing the first letter of '2' and '1', '2' is greater than '1', so the string '2' is not less than '12', outputting false
    3.  C. true is the output because this is a comparison of different types, so values get converted to numbers, and so the string '2' would get converted to 2 and 2 equals 2, outputting true
    4.  D. false is the output because in strict equality comparison, if the values being compared are of different types, then it immediately returns false without trying to convert the values
    5.  E. false is the output because it's a comparison of different types, so it would be a numeric comparison and so true would be converted into its numeric value of 1, and 1 does not equal 2, outputting false
    6.  F. true is the output because the types are the same, and Boolean(2) is true because any value besides 0, null, undefined, NaN, "", are true, so true === true is true
15. == will compare two values regardless of their data type, so it would try to automatically convert the data types to match based on what it sees as most fit. However, === is strict on the data type, so it checks if the values or variables are of the same type of data before going further into seeing if they are equal. If they are not of the same data type, it immediately outputs false.
17. The result would be the function modifyArray returns the array [2,4,6]. This is because the function declaration of modifyArray is that we pass in two parameters, one being an array and another is a function. In modifyArray, we create a new array called newArr, then we traverse the array parameter and add to the new array the result of passing in the current element in the old array to the callback function, or what is returned from the callback function. Our callback function is doSomething, and we have a num parameter. doSomething just doubles the num parameter. So, we are doubling every element in the array parameter and storing that in the new array, so our new array has elements that are double of that in the old array. Then after we iterate through each element in the old array and finish the for loop, we return the new array. Thus, when we call modifyArray([1,2,3], doSomething), we are just doubling [1,2,3] to get [2,4,6]
19. The output is 1 4 3 2 each on their respective lines. This is because when printNums() gets called, we pring 1 to the console, then we set timeout to call a function that prints out 2, but with the delay of 1 second, and then it set timeout to call a function to print out 3 with no delay, however all the code for queued messages gets to be completed first, so the next line says print out 4 so that gets printed out before any setTimeout does. Thus, 4 gets printed out and then 3 gets printed out immediately after with no delay, then 1 second later 2 gets printed out, which is why we have 1 4 3 2.